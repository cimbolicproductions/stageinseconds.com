{
  "task": "Task 7: Add Rate Limiting",
  "context": {
    "project": "stageinseconds.com",
    "previousProgress": {
      "task-1": "completed - ESLint, Prettier, and pre-commit hooks configured",
      "task-2": "completed - Database migrations with Drizzle ORM",
      "task-3": "completed - Unit tests for validators, auth, and SSRF protection",
      "task-4-part-1": "completed - Integration test infrastructure (db helpers, api helpers, MSW mocks)",
      "task-4-part-2": "completed - Auth integration tests (16 tests, skipped)",
      "task-4-part-3": "completed - Billing integration tests (29 tests, skipped)",
      "task-4-part-4": "completed - Photo processing integration tests (39 tests, skipped)",
      "task-4-part-5": "completed - Job management integration tests (20 tests, skipped) + DELETE endpoint",
      "task-5": "completed - CI/CD pipeline with GitHub Actions (test, security, deploy workflows)",
      "task-6": "completed - Error tracking and logging with Pino logger"
    },
    "currentTask": "task-7",
    "status": "not started",
    "totalTestCount": "104 tests (16 auth + 29 billing + 39 photo processing + 20 job management)"
  },
  "objective": "Add rate limiting to API endpoints to prevent abuse and ensure fair usage. Protect authentication endpoints from brute force attacks, limit resource-intensive operations (photo processing), and prevent API abuse.",
  "requirements": {
    "dependencies": {
      "install": [
        "@hono/rate-limiter - Official Hono rate limiting middleware",
        "OR hono-rate-limiter - Alternative rate limiter for Hono"
      ],
      "notes": [
        "Use in-memory store for development/small deployments",
        "Can be extended with Redis store for production scaling",
        "Hono has built-in rate limiting support"
      ]
    },
    "rateLimitMiddleware": {
      "file": "apps/web/src/middleware/rateLimit.ts",
      "configurations": [
        {
          "name": "authRateLimit",
          "endpoints": ["/api/auth/signin", "/api/auth/signup", "/api/auth/send-verification"],
          "limit": "5 requests per minute per IP",
          "purpose": "Prevent brute force attacks on authentication endpoints",
          "window": "1 minute (60000ms)",
          "keyGenerator": "IP address",
          "statusCode": 429,
          "message": "Too many authentication attempts. Please try again in 1 minute."
        },
        {
          "name": "photoProcessingRateLimit",
          "endpoints": ["/api/process-photos"],
          "limit": "10 requests per minute per authenticated user",
          "purpose": "Prevent abuse of expensive photo processing operations",
          "window": "1 minute (60000ms)",
          "keyGenerator": "userId (authenticated users only)",
          "statusCode": 429,
          "message": "Too many photo processing requests. Please try again in 1 minute."
        },
        {
          "name": "billingRateLimit",
          "endpoints": ["/api/billing/create-checkout", "/api/billing/stripe-webhook"],
          "limit": "20 requests per minute per user/IP",
          "purpose": "Prevent abuse of payment endpoints",
          "window": "1 minute (60000ms)",
          "keyGenerator": "userId or IP address",
          "statusCode": 429,
          "message": "Too many billing requests. Please try again in 1 minute."
        },
        {
          "name": "generalApiRateLimit",
          "endpoints": ["/api/*"],
          "limit": "100 requests per minute per IP",
          "purpose": "General API protection against DoS",
          "window": "1 minute (60000ms)",
          "keyGenerator": "IP address",
          "statusCode": 429,
          "message": "Too many requests. Please try again in 1 minute.",
          "applyGlobally": true,
          "skipRoutes": ["Routes with stricter limits applied"]
        }
      ],
      "implementation": {
        "features": [
          "Create rate limiter factory function for different configurations",
          "Support both IP-based and user-based rate limiting",
          "Include Retry-After header in 429 responses",
          "Log rate limit violations using Pino logger",
          "Skip rate limiting for test environment (NODE_ENV=test)",
          "Configurable via environment variables (optional)"
        ],
        "responseFormat": {
          "statusCode": 429,
          "headers": {
            "Retry-After": "60",
            "X-RateLimit-Limit": "5",
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1699564920"
          },
          "body": {
            "error": "Too many requests. Please try again later.",
            "retryAfter": 60
          }
        }
      }
    },
    "serverIntegration": {
      "file": "apps/web/__create/index.ts",
      "tasks": [
        "Import rate limiting middleware functions",
        "Apply generalApiRateLimit globally to all /api/* routes",
        "Apply authRateLimit to authentication endpoints BEFORE general rate limit",
        "Apply photoProcessingRateLimit to /api/process-photos",
        "Apply billingRateLimit to billing endpoints",
        "Ensure more restrictive rate limits are applied first (middleware order matters)"
      ],
      "middlewareOrder": [
        "1. Request ID middleware (already exists)",
        "2. Context storage (already exists)",
        "3. Rate limiting middleware (NEW - apply before route handlers)",
        "4. CORS middleware (already exists)",
        "5. Auth middleware (already exists)",
        "6. Route handlers",
        "7. Error handler (already exists)"
      ]
    },
    "testing": {
      "file": "test/middleware/rateLimit.test.ts",
      "testCases": [
        {
          "category": "Authentication Rate Limiting",
          "tests": [
            "Should allow 5 signin requests within 1 minute from same IP",
            "Should block 6th signin request from same IP within 1 minute",
            "Should return 429 status code on rate limit exceeded",
            "Should include Retry-After header in response",
            "Should include rate limit headers (X-RateLimit-*)",
            "Should reset rate limit after 1 minute window expires",
            "Should track separate rate limits for different IPs",
            "Should apply to /api/auth/signin, /api/auth/signup, /api/auth/send-verification"
          ]
        },
        {
          "category": "Photo Processing Rate Limiting",
          "tests": [
            "Should allow 10 photo processing requests per minute per user",
            "Should block 11th request from same user within 1 minute",
            "Should track rate limits by userId (not IP) for authenticated users",
            "Should return appropriate error message for photo processing",
            "Should reset rate limit after 1 minute",
            "Should allow different users to process photos independently"
          ]
        },
        {
          "category": "Billing Rate Limiting",
          "tests": [
            "Should allow 20 billing requests per minute per user",
            "Should block 21st request within 1 minute",
            "Should apply to /api/billing/create-checkout",
            "Should apply to /api/billing/stripe-webhook (prevent webhook spam)"
          ]
        },
        {
          "category": "General API Rate Limiting",
          "tests": [
            "Should allow 100 requests per minute per IP to general API endpoints",
            "Should block 101st request within 1 minute",
            "Should apply to all /api/* routes not covered by specific rate limits",
            "Should not interfere with stricter rate limits on auth/photo/billing endpoints"
          ]
        },
        {
          "category": "Edge Cases",
          "tests": [
            "Should handle missing IP address gracefully",
            "Should handle missing userId for authenticated endpoints",
            "Should not apply rate limiting in test environment",
            "Should handle concurrent requests correctly",
            "Should cleanup expired rate limit entries (prevent memory leak)"
          ]
        }
      ],
      "mockSetup": [
        "Mock request objects with different IP addresses",
        "Mock authenticated user sessions with different userIds",
        "Mock Date.now() to control time for testing expiry",
        "Use beforeEach to reset rate limiter state between tests"
      ]
    },
    "documentation": {
      "apiDocumentation": {
        "file": "API_DOCUMENTATION.md",
        "newSection": "Rate Limits",
        "content": [
          "Document all rate limits for each endpoint category",
          "Explain what happens when rate limit is exceeded (429 response)",
          "Show example 429 response with headers",
          "Explain rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, Retry-After)",
          "Provide guidance on handling rate limits in client code",
          "Explain that rate limits are per IP for unauthenticated endpoints, per user for authenticated endpoints"
        ],
        "exampleResponse": {
          "status": 429,
          "headers": {
            "Retry-After": "60",
            "X-RateLimit-Limit": "5",
            "X-RateLimit-Remaining": "0",
            "X-RateLimit-Reset": "1699564920"
          },
          "body": {
            "error": "Too many authentication attempts. Please try again in 1 minute.",
            "retryAfter": 60
          }
        }
      },
      "deploymentDoc": {
        "file": "DEPLOYMENT.md",
        "update": "Add section about rate limiting configuration and monitoring in production"
      },
      "securityDoc": {
        "file": "docs/SECURITY.md (create if doesn't exist)",
        "content": [
          "Rate limiting as part of security measures",
          "How rate limits protect against brute force attacks",
          "How rate limits prevent DoS attacks",
          "Monitoring rate limit violations in logs"
        ]
      }
    },
    "environmentVariables": {
      "optional": [
        "RATE_LIMIT_ENABLED - Enable/disable rate limiting (default: true, false in test)",
        "RATE_LIMIT_WINDOW - Rate limit window in milliseconds (default: 60000)",
        "RATE_LIMIT_AUTH_MAX - Max auth requests per window (default: 5)",
        "RATE_LIMIT_PHOTO_MAX - Max photo processing requests per window (default: 10)",
        "RATE_LIMIT_BILLING_MAX - Max billing requests per window (default: 20)",
        "RATE_LIMIT_GENERAL_MAX - Max general API requests per window (default: 100)"
      ],
      "notes": [
        "Environment variables are optional - sensible defaults provided",
        "Useful for adjusting limits in production without code changes",
        "Rate limiting should be DISABLED in test environment automatically"
      ]
    }
  },
  "technicalDetails": {
    "storageOptions": {
      "inMemory": {
        "pros": ["Simple", "Fast", "No external dependencies", "Good for single-instance deployments"],
        "cons": ["Doesn't work across multiple server instances", "Lost on server restart"],
        "useCase": "Development, small deployments, Vercel serverless (each instance independent)"
      },
      "redis": {
        "pros": ["Works across multiple instances", "Persistent", "Scalable"],
        "cons": ["Requires Redis setup", "Additional infrastructure cost"],
        "useCase": "Production with multiple server instances",
        "implementation": "Can be added later if needed"
      }
    },
    "ipAddressExtraction": {
      "headers": [
        "x-forwarded-for (preferred for proxied requests)",
        "x-real-ip (fallback)",
        "req.socket.remoteAddress (direct connection)"
      ],
      "considerations": [
        "Handle proxy headers correctly (Vercel, Cloudflare, etc.)",
        "Validate IP address format",
        "Handle IPv6 addresses",
        "Be aware of IP spoofing - use trusted proxy headers only"
      ]
    },
    "logging": {
      "logEvents": [
        "Log when rate limit is exceeded (warn level)",
        "Include: IP address, userId (if authenticated), endpoint, limit type",
        "Use existing Pino logger from Task 6"
      ],
      "exampleLog": {
        "level": "warn",
        "message": "Rate limit exceeded",
        "ip": "192.168.1.1",
        "userId": "user_123",
        "endpoint": "/api/auth/signin",
        "limitType": "authRateLimit",
        "requestId": "abc123"
      }
    }
  },
  "verification": {
    "local": [
      "Run unit tests: npm run test -- test/middleware/rateLimit",
      "Start dev server: npm run dev",
      "Make 5 consecutive signin requests - all should succeed",
      "Make 6th signin request - should get 429",
      "Check response includes Retry-After header",
      "Wait 1 minute and verify rate limit resets",
      "Test photo processing endpoint (10 requests limit)",
      "Verify logs show rate limit violations"
    ],
    "integration": [
      "Test with integration test suite",
      "Verify rate limits don't break existing tests (tests should not be rate limited)",
      "Test concurrent requests from multiple users",
      "Verify different endpoints have independent rate limits"
    ]
  },
  "deliverables": [
    "src/middleware/rateLimit.ts - Rate limiting middleware implementations",
    "__create/index.ts - Updated with rate limiting middleware",
    "test/middleware/rateLimit.test.ts - Comprehensive rate limit tests",
    "API_DOCUMENTATION.md - Updated with rate limit information",
    "DEPLOYMENT.md - Updated with rate limiting section",
    "docs/SECURITY.md - Created or updated with rate limiting security info",
    "package.json - Dependencies updated (@hono/rate-limiter or alternative)"
  ],
  "notes": [
    "Rate limiting is crucial for production security and preventing abuse",
    "Different endpoints need different limits based on their cost/sensitivity",
    "Authentication endpoints need strict limits (5/min) to prevent brute force",
    "Photo processing is expensive - limit to 10/min per user",
    "In-memory storage is sufficient for Vercel serverless (each instance is independent)",
    "Rate limits should be logged but not block legitimate users",
    "Consider user experience - provide clear error messages with retry time",
    "Rate limiting middleware should be applied BEFORE route handlers",
    "More restrictive limits should be applied first (middleware order matters)",
    "Ensure rate limiting doesn't break integration tests (disable in test environment)"
  ],
  "bestPractices": [
    "Use IP address for unauthenticated endpoints (prevent spoofing with trusted headers)",
    "Use userId for authenticated endpoints (better UX, per-user limits)",
    "Include informative error messages telling users when they can retry",
    "Always include Retry-After header in 429 responses",
    "Log rate limit violations for monitoring and abuse detection",
    "Make limits configurable via environment variables for production tuning",
    "Don't apply rate limits in test environment (would break tests)",
    "Consider implementing exponential backoff for repeat offenders (future enhancement)",
    "Monitor rate limit violations in production to detect abuse patterns"
  ],
  "futureEnhancements": [
    "Redis store for multi-instance deployments (when scaling)",
    "Exponential backoff for repeat offenders",
    "Whitelist/blacklist IP addresses",
    "Different rate limits for different user tiers (e.g., premium users get higher limits)",
    "Rate limit analytics dashboard",
    "Automated IP banning for severe abuse"
  ],
  "instruction": "Please complete Task 7: Add rate limiting middleware to protect API endpoints from abuse. Install rate limiting library, create middleware with different configurations for auth/photo/billing/general endpoints, integrate with server, add comprehensive tests, and update documentation. Ensure rate limits are appropriate for each endpoint type and don't break existing functionality."
}
